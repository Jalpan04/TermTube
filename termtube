#!/bin/bash

# TermTube - A TUI wrapper for yt-dlp
# Author: TermTube Dev
# Version: 1.0

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check for dependencies
DEPENDENCIES=("yt-dlp" "jq" "fzf" "ffmpeg")
MISSING_DEPS=()

for dep in "${DEPENDENCIES[@]}"; do
    if ! command -v "$dep" &> /dev/null; then
        MISSING_DEPS+=("$dep")
    fi
done

if [ ${#MISSING_DEPS[@]} -ne 0 ]; then
    echo -e "${RED}Error: Missing dependencies: ${MISSING_DEPS[*]}${NC}"
    echo "Please install them using your package manager or run install.sh"
    exit 1
fi

# Function to search and download
search_and_download() {
    echo -e "${BLUE}TermTube - YouTube Downloader${NC}"
    echo -n "Enter search query: "
    read -r QUERY

    if [ -z "$QUERY" ]; then
        echo -e "${RED}Search query cannot be empty.${NC}"
        exit 1
    fi

    echo -e "${YELLOW}Searching for '$QUERY'...${NC}"

    # Search and parse results into a format for fzf
    # Format: Title | Channel | Duration | ID
    RESULTS=$(yt-dlp "ytsearch15:$QUERY" --dump-json --flat-playlist 2>/dev/null | \
        jq -r '[.title, .channel, .duration_string, .id] | @tsv')

    if [ -z "$RESULTS" ]; then
        echo -e "${RED}No results found.${NC}"
        exit 1
    fi

    # Select video using fzf
    SELECTED=$(echo "$RESULTS" | fzf --delimiter=$'\t' --with-nth=1,2,3 \
        --header="Select a video (Enter to confirm)" \
        --color=fg:white,bg:black,hl:blue,fg+:blue,bg+:black,hl+:cyan \
        --layout=reverse --height=40% --border)

    if [ -z "$SELECTED" ]; then
        echo "No video selected. Exiting."
        exit 0
    fi

    # Extract Video ID (last field)
    VIDEO_ID=$(echo "$SELECTED" | awk -F'\t' '{print $4}')
    VIDEO_TITLE=$(echo "$SELECTED" | awk -F'\t' '{print $1}')

    echo -e "${GREEN}Selected: $VIDEO_TITLE${NC}"

    # Get available formats
    echo -e "${YELLOW}Fetching formats...${NC}"
    # We use yt-dlp -F to list formats, but for parsing we'll dump json again strictly for formats if we wanted robust parsing
    # But yt-dlp's -F output is readable for humans. Let's pipe that into fzf for selection.
    
    FORMAT_SELECTION=$(yt-dlp -F "$VIDEO_ID" 2>/dev/null | grep -E "^[0-9]+|ID" | \
        fzf --header="Select Quality/Format" --layout=reverse --height=40% --border)

    if [ -z "$FORMAT_SELECTION" ]; then
        echo "No format selected. Defaulting to best video+audio."
        FORMAT_OPT=""
    else
        FORMAT_CODE=$(echo "$FORMAT_SELECTION" | awk '{print $1}')
        FORMAT_OPT="-f $FORMAT_CODE"
        echo -e "${GREEN}Selected Format Code: $FORMAT_CODE${NC}"
    fi

    # Ask for download location
    echo -n "Download to current directory? [Y/n]: "
    read -r LOC_CONFIRM
    LOC_CONFIRM=${LOC_CONFIRM:-Y}

    OUTPUT_TEMPLATE="%(title)s.%(ext)s"
    
    if [[ "$LOC_CONFIRM" =~ ^[Nn]$ ]]; then
        echo -n "Enter target directory: "
        read -r TARGET_DIR
        mkdir -p "$TARGET_DIR"
        cd "$TARGET_DIR" || exit
    fi

    echo -e "${BLUE}Downloading...${NC}"
    
    # Download
    # shellcheck disable=SC2086
    yt-dlp $FORMAT_OPT -o "$OUTPUT_TEMPLATE" "$VIDEO_ID"

    echo -e "${GREEN}Download Complete!${NC}"
}

# Run the main function
search_and_download
